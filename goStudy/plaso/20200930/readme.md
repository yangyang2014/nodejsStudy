1、使用go语言实现一个http服务，服务中提供邀请码的生成、删除和初始化方法，对外暴露生成和删除方法
   
  1.1 如何实现高并发下的邀请码安全
     1.1.1保证单个线程下运行程序是正常的
     1.1.2保证多个线程下不同时序下程序也是安全的

     flag[index]读写都存在，需要分为三个场景

     第一个场景 对同一个元素的操作由并发改为串行，线程安全
    线程1
     |-----|----------|-----|
       读     其他操作    写
    线程2
                                |-----|----------|-----|
                                  读     其他操作    写
     第二个场景  存在线程安全问题
    线程1
     |-----|----------|-----|
       读     其他操作    写
    线程2
              |-----|----------|-----|
                读     其他操作    写

    第三个场景  存在线程安全问题
    线程1
     |-----|--------------------------------|-----|
       读                 其他操作              写
    线程2
              |-----|----------|-----|
                读     其他操作    写

    后面两个场景可以通过cas，失败重试的方法来实现

    还有一个场景就是 有没有可能刚刚新建的邀请码，未发出drop而drop了 。
    有可能，同一个邀请码drop两次，第一个次成功了，后一次始终没有机会成功
    无法控制request发送几次（也可能存在攻击行为，这种情况不考虑，只考虑单纯的客户端），试图去解决drop两次的问题，思考是否会引起其他问题？
    同一个课程drop两次，第一次drop成功，同样的邀请码又被另一个课程申请到了，此时第二次drop成功。drop之前判断邀请码是否被占用，这两种情况下都占用了。
    待思考：这样的时序执行时是否存在cas失败？

    高并发情况下不是所有的restapi 都可以重复调用的 比如修改数据的接口。占用资源的释放接口。

    也就是说如何在后端做到防止在某个时间范围内的重复drop请求。
    目前的思路：让drop立即处理，不要有等待情况，资源占用时考虑cas，不占用时就不处理了不需要考虑cas。防止其他不占时，另个相同的邀请码生成了，for之后又cas了。从某种程度上减少了出现问题的概率。

    这个和扣钱问题不幂等有关相似。
    https://zhuanlan.zhihu.com/p/95161747